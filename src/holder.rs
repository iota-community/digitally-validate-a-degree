use shared_utils::create_did_document;
use shared_utils::get_memstorage;
use shared_utils::get_funded_client;
use anyhow::Ok;
use identity_iota::core::Object;
use identity_iota::credential::DecodedJwtCredential;
use identity_iota::credential::DecodedJwtPresentation;
use identity_iota::credential::Jwt;
use identity_iota::credential::JwtCredentialValidatorUtils;
use identity_iota::credential::JwtPresentationOptions;
use identity_iota::credential::JwtPresentationValidatorUtils;
use identity_iota::credential::Presentation;
use identity_iota::credential::PresentationBuilder;
use identity_iota::did::CoreDID;
use identity_iota::document::verifiable::JwsVerificationOptions;
use identity_iota::storage::JwkDocumentExt;
use identity_iota::storage::JwsSignatureOptions;

use identity_iota::core::json;
use identity_iota::core::Duration;
use identity_iota::core::FromJson;
use identity_iota::core::Timestamp;
use identity_iota::core::Url;
use identity_iota::credential::CredentialBuilder;
use identity_iota::credential::FailFast;
use identity_iota::credential::JwtCredentialValidationOptions;
use identity_iota::credential::JwtCredentialValidator;
use identity_iota::credential::Subject;
use identity_iota::credential::SubjectHolderRelationship;
use identity_iota::did::DID;
use identity_iota::iota::IotaDocument;
use identity_iota::resolver::Resolver;

fn main() -> anyhow::Result<()> {
    
    pub async fn create_presentation(vc_jwt: String) -> anyhow::Result<()> {

        // A unique random challenge generated by the requester per presentation can mitigate replay attacks.
        let challenge: &str = "475a7984-1bb5-4c4c-a56f-822bccd46440";

        // The verifier and holder also agree that the signature should have an expiry date
        // 10 minutes from now.
        let expires: Timestamp = Timestamp::now_utc()
            .checked_add(Duration::minutes(10))
            .unwrap();
        
    // create new holder account with did document
    let holder_storage = get_memstorage().await?;
    let holder_identity_client = get_funded_client(&holder_storage).await?;
    let (holder_document, holder_vm_fragment) =
        create_did_document(&holder_identity_client, &holder_storage).await?;

    // Create an unsigned Presentation from the previously issued Verifiable Credential.
    let presentation =
        PresentationBuilder::new(holder_document.id().to_url().into(), Default::default())
            .credential(vc_jwt.clone())
            .build()?;

    // Create a JWT verifiable presentation using the holder's verification method
    // and include the requested challenge and expiry timestamp.
    let presentation_jwt: Jwt = holder_document
        .create_presentation_jwt(
            &presentation,
            &holder_storage,
            &holder_vm_fragment,
            &JwsSignatureOptions::default().nonce(challenge.to_owned()),
            &JwtPresentationOptions::default().expiration_date(expires),
        )
        .await?;

    // ===========================================================================
    // Holder sends a verifiable presentation to the verifier.
    // ===========================================================================
    println!("Sending presentation (as JWT) to the verifier: {presentation:#}");

    Ok(())
}
    Ok(())
}