use std::env::Args;

use shared_utils::create_did_document;
use shared_utils::get_memstorage;
use shared_utils::get_funded_client;
use anyhow::Ok;
use identity_iota::credential::Jwt;
use identity_iota::credential::JwtPresentationOptions;
use identity_iota::credential::PresentationBuilder;
use identity_iota::storage::JwkDocumentExt;
use identity_iota::storage::JwsSignatureOptions;
use identity_iota::core::Duration;
use identity_iota::core::Timestamp;
use identity_iota::did::DID;
use shared_utils::pretty_print_json;

    pub async fn create_presentation(vc_jwt: String) -> anyhow::Result<()> {

        // A unique random challenge generated by the requester per presentation can mitigate replay attacks.
        let challenge: &str = "475a7984-1bb5-4c4c-a56f-822bccd46440";

        // The verifier and holder also agree that the signature should have an expiry date
        // 10 minutes from now.
        let expires: Timestamp = Timestamp::now_utc()
            .checked_add(Duration::minutes(10))
            .unwrap();
        
    // create new holder account with did document
    let holder_storage = get_memstorage().await?;
    let holder_identity_client = get_funded_client(&holder_storage).await?;
    let (holder_document, holder_vm_fragment) =
        create_did_document(&holder_identity_client, &holder_storage).await?;

    // Create an unsigned Presentation from the previously issued Verifiable Credential.
    let presentation =
        PresentationBuilder::new(holder_document.id().to_url().into(), Default::default())
            .credential(vc_jwt.clone())
            .build()?;

    // Create a JWT verifiable presentation using the holder's verification method
    // and include the requested challenge and expiry timestamp.
    let presentation_jwt: Jwt = holder_document
        .create_presentation_jwt(
            &presentation,
            &holder_storage,
            &holder_vm_fragment,
            &JwsSignatureOptions::default().nonce(challenge.to_owned()),
            &JwtPresentationOptions::default().expiration_date(expires),
        )
        .await?;

    // ===========================================================================
    // Holder sends a verifiable presentation to the verifier.
    // ===========================================================================
    println!("Sending presentation (as JWT) to the verifier: {presentation:#}");
    // println!("{}", presentation_jwt.as_str());

    //pretty_print_json("Verifiable Presentation JWT", &presentation.to_string());
    // pretty_print_json("Verifiable Presentation JWT", &presentation_jwt.as_str());


    Ok(())
}

#[tokio::main]
async fn main() -> anyhow::Result<()> {

    let args: Vec<String> = std::env::args().collect();

    if args.len() < 2 {
        eprintln!("Usage: cargo run --bin holder <verifiable_credential_jwt_string>");
        eprintln!("Example: cargo run --bin holder 'eyJhbGciOiJEd09...[your VC JWT here]...'");
        return Err(anyhow::anyhow!("Missing Verifiable Credential JWT argument."));
    }

    let vc_jwt_string = &args[1];
    println!("Received Verifiable Credential JWT: {}", vc_jwt_string);

    // Call the create_presentation function with the received VC JWT
    let _presentation_jwt = create_presentation(vc_jwt_string.to_string()).await?;

    // You can add further logic here if needed, like saving the presentation_jwt or passing it on.
    println!("Successfully created Verifiable Presentation.");

    Ok(())
}