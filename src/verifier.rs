use std::collections::HashMap;

// Using `anyhow::Result` for error handling
use anyhow::Result;

use identity_iota::document::verifiable::JwsVerificationOptions;
// Import from your shared_utils crate
use shared_utils::{create_did_document, get_funded_client, get_memstorage, pretty_print_json};

// Standard identity_iota imports
use identity_eddsa_verifier::EdDSAJwsVerifier;
use identity_iota::core::Object;
use identity_iota::credential::{
    DecodedJwtCredential, DecodedJwtPresentation, Jwt, JwtCredentialValidationOptions,
    JwtCredentialValidator, JwtCredentialValidatorUtils, JwtPresentationValidationOptions,
    JwtPresentationValidator, JwtPresentationValidatorUtils, SubjectHolderRelationship, FailFast,
};
use identity_iota::did::{CoreDID, DID};
// use identity_iota::iota_core::document::verifiable::JwsVerificationOptions; // Corrected path based on previous discussions
use identity_iota::iota::IotaDocument; // Corrected path based on previous discussions
use identity_iota::resolver::Resolver;
use identity_iota::core::{Duration, Timestamp};


// This function will perform the actual verification.
// It takes the raw JWT string as input.
pub async fn verify_presentation(presentation_jwt_str: String) -> Result<()> {
    println!("\n--- Step 9: Verifier Receives and Validates Verifiable Presentation ---");

    // Convert the input string into a Jwt type
    let jwt: Jwt = Jwt::new(presentation_jwt_str);
    println!("Received Presentation JWT string.");

    // Create a new client for the verifier.
    // It's important to note that the verifier operates independently of the issuer and holder.
    let verifier_storage = &get_memstorage().await?;
    let verifier_client = get_funded_client(verifier_storage).await?;
    println!("Verifier client initialized.");

    // ===========================================================================
    // Verifier's Requirements (simulated challenge and expiry from request_presentation_challenge)
    // ===========================================================================

    // A unique random challenge generated by the requester per presentation can mitigate replay attacks.
    // This MUST match the challenge the holder used when creating the presentation.
    let expected_challenge: &str = "475a7984-1bb5-4c4c-a56f-822bccd46440";
    println!("Verifier's expected challenge: {}", expected_challenge);

    // The verifier and holder also agree that the signature should have an expiry date
    // 10 minutes from now. This is checked as part of validation.
    let _expected_expires: Timestamp = Timestamp::now_utc()
        .checked_add(Duration::minutes(10))
        .unwrap(); // This value is for example, actual check is part of validation.

    // The verifier wants the following requirements to be satisfied:
    // - JWT verification of the presentation (including checking the requested challenge to mitigate replay attacks)
    // - JWT verification of the credentials within the presentation.
    // - The presentation holder must always be the subject, regardless of the presence of the nonTransferable property
    // - The issuance date must not be in the future.

    let presentation_verifier_options: JwsVerificationOptions =
        JwsVerificationOptions::default().nonce(expected_challenge.to_owned());

    // Initialize a resolver. The resolver is used to fetch DID Documents from the IOTA Tangle.
    // It needs to be configured with an IOTA client.
    let mut resolver: Resolver<IotaDocument> = Resolver::new();
    resolver.attach_iota_handler((*verifier_client).clone());
    println!("DID Resolver initialized.");

    // 9.1: Validate the Verifiable Presentation's signature and structure.
    // First, extract the holder's DID from the presentation JWT.
    // This expects `&Jwt`, so we pass `&jwt`.
    let holder_did: CoreDID = JwtPresentationValidatorUtils::extract_holder(&jwt)?;
    println!("Extracted Holder DID from VP: {}", holder_did);

    // Resolve the holder's DID Document from the Tangle.
    // This document contains the public key needed to verify the holder's signature on the VP.
    let holder: IotaDocument = resolver.resolve(&holder_did).await?;
    println!("Resolved Holder's DID Document.");

    // Validate the presentation itself. This checks the holder's signature and the overall VP structure.
    let presentation_validation_options = JwtPresentationValidationOptions::default()
        .presentation_verifier_options(presentation_verifier_options);

    let presentation: DecodedJwtPresentation<Jwt> =
        JwtPresentationValidator::with_signature_verifier(EdDSAJwsVerifier::default()).validate(
            &jwt, // Pass `&Jwt`
            &holder, // Verify using the holder's DID Document
            &presentation_validation_options,
        )?;

    println!("Verifiable Presentation successfully validated (holder's signature checked).");
    pretty_print_json("Decoded Verifiable Presentation", &serde_json::to_string_pretty(&presentation.presentation)?);


    // 9.2: Validate the included Verifiable Credentials.
    // Concurrently resolve the issuers' DID Documents.
    // A VP can contain multiple VCs, potentially from different issuers.
    let jwt_credentials: &Vec<Jwt> = &presentation.presentation.verifiable_credential;
    println!("Found {} Verifiable Credentials in the Presentation.", jwt_credentials.len());

    let issuers: Vec<CoreDID> = jwt_credentials
        .iter()
        // `extract_issuer_from_jwt` expects `&Jwt`, so we pass `jwt_vc` directly (which is `&Jwt`)
        .map(JwtCredentialValidatorUtils::extract_issuer_from_jwt)
        .collect::<Result<Vec<CoreDID>, _>>()?;

    // Resolve all issuer DID Documents in parallel for efficiency.
    let issuers_documents: HashMap<CoreDID, IotaDocument> =
        resolver.resolve_multiple(&issuers).await?;
    println!("Resolved Issuer(s)' DID Document(s).");


    // Validate each credential contained within the presentation.
    // This checks the issuer's signature on the VC and the VC's content.
    let credential_validator: JwtCredentialValidator<EdDSAJwsVerifier> =
        JwtCredentialValidator::with_signature_verifier(EdDSAJwsVerifier::default());

    // Configure validation options for credentials:
    // - `SubjectHolderRelationship::AlwaysSubject`: Ensures that the subject of the credential
    //   is always the same as the holder of the presentation. This prevents cases where
    //   a holder presents a credential issued to someone else.
    let validation_options: JwtCredentialValidationOptions =
        JwtCredentialValidationOptions::default().subject_holder_relationship(
            holder_did.to_url().into(), // The holder's DID must be the subject of the VC
            SubjectHolderRelationship::AlwaysSubject,
        );

    for (index, jwt_vc) in jwt_credentials.iter().enumerate() {
        // Retrieve the correct issuer document for this specific credential.
        let issuer_document: &IotaDocument = &issuers_documents[&issuers[index]];

        let decoded_credential: DecodedJwtCredential<Object> = credential_validator
            .validate::<_, Object>(
                jwt_vc, // `jwt_vc` is already `&Jwt`, correct here.
                issuer_document, // Verify using the issuer's DID Document
                &validation_options,
                FailFast::FirstError, // Stop at the first error found
            )
            .unwrap(); // `unwrap` here means we expect validation to pass. In real code, handle errors gracefully.

        println!("Credential #{} successfully validated: {:#?}", index + 1, decoded_credential.credential);
        pretty_print_json(&format!("Decoded Verifiable Credential #{}", index + 1), &serde_json::to_string_pretty(&decoded_credential.credential)?);
    }

    println!("\nSUCCESS: All Verifiable Credentials within the Presentation were successfully validated!");

    Ok(())
}

// The main entry point for the verifier binary.
// It takes the JWT presentation as a command-line argument.
#[tokio::main]
async fn main() -> Result<()> {
    let args: Vec<String> = std::env::args().collect();

    if args.len() < 2 {
        eprintln!("Usage: cargo run --bin verifier <verifiable_presentation_jwt_string>");
        eprintln!("Example: cargo run --bin verifier 'eyJhbGciOiJEd09...[your VP JWT here]...'");
        return Err(anyhow::anyhow!("Missing Verifiable Presentation JWT argument."));
    }

    let vp_jwt_string = &args[1];
    println!("Received Verifiable Presentation JWT from command line.");

    // Call the verification function
    verify_presentation(vp_jwt_string.to_string()).await?;

    println!("\n--- Verifier Process Completed ---");

    Ok(())
}