use std::collections::HashMap;
use identity_iota::credential::JwtPresentationValidationOptions;
use shared_utils::get_memstorage;
use shared_utils::get_funded_client;
use anyhow::Ok;
use identity_eddsa_verifier::EdDSAJwsVerifier;
use identity_iota::core::Object;
use identity_iota::credential::DecodedJwtCredential;
use identity_iota::credential::DecodedJwtPresentation;
use identity_iota::credential::Jwt;
use identity_iota::credential::JwtCredentialValidatorUtils;
use identity_iota::credential::JwtPresentationValidator;
use identity_iota::credential::JwtPresentationValidatorUtils;
use identity_iota::did::CoreDID;
use identity_iota::document::verifiable::JwsVerificationOptions;
use identity_iota::core::Duration;
use identity_iota::core::Timestamp;
use identity_iota::credential::FailFast;
use identity_iota::credential::JwtCredentialValidationOptions;
use identity_iota::credential::JwtCredentialValidator;
use identity_iota::credential::SubjectHolderRelationship;
use identity_iota::did::DID;
use identity_iota::iota::IotaDocument;
use identity_iota::resolver::Resolver;


#[tokio::main]
async fn main() -> anyhow::Result<()> {

    pub async fn verify_presentation(presentation_jwt: String) -> anyhow::Result<()> {

        let jwt: Jwt = Jwt::new(presentation_jwt);
    
        // create new client for verifier
        // new client actually not necessary, but shows, that client is independent from issuer and holder
        let verifier_storage = &get_memstorage().await?;
        let verifier_client = get_funded_client(verifier_storage).await?;
    
        // ===========================================================================
        // Verifier sends the holder a challenge and requests a signed Verifiable Presentation.
        // ===========================================================================
    
        // A unique random challenge generated by the requester per presentation can mitigate replay attacks.
        let challenge: &str = "475a7984-1bb5-4c4c-a56f-822bccd46440";
    
        // The verifier and holder also agree that the signature should have an expiry date
        // 10 minutes from now.
        let expires: Timestamp = Timestamp::now_utc()
            .checked_add(Duration::minutes(10))
            .unwrap();
    
        // The verifier wants the following requirements to be satisfied:
        // - JWT verification of the presentation (including checking the requested challenge to mitigate replay attacks)
        // - JWT verification of the credentials.
        // - The presentation holder must always be the subject, regardless of the presence of the nonTransferable property
        // - The issuance date must not be in the future.
    
        let presentation_verifier_options: JwsVerificationOptions =
            JwsVerificationOptions::default().nonce(challenge.to_owned());
    
        let mut resolver: Resolver<IotaDocument> = Resolver::new();
        resolver.attach_iota_handler((*verifier_client).clone());
    
        // Resolve the holder's document.
        let holder_did: CoreDID = JwtPresentationValidatorUtils::extract_holder(&jwt)?;
        let holder: IotaDocument = resolver.resolve(&holder_did).await?;
    
        // Validate presentation. Note that this doesn't validate the included credentials.
        let presentation_validation_options = JwtPresentationValidationOptions::default()
            .presentation_verifier_options(presentation_verifier_options);
        let presentation: DecodedJwtPresentation<Jwt> =
            JwtPresentationValidator::with_signature_verifier(EdDSAJwsVerifier::default()).validate(
                &jwt,
                &holder,
                &presentation_validation_options,
            )?;
    
        // Concurrently resolve the issuers' documents.
        let jwt_credentials: &Vec<Jwt> = &presentation.presentation.verifiable_credential;
        let issuers: Vec<CoreDID> = jwt_credentials
            .iter()
            .map(JwtCredentialValidatorUtils::extract_issuer_from_jwt)
            .collect::<Result<Vec<CoreDID>, _>>()?;
        let issuers_documents: HashMap<CoreDID, IotaDocument> =
            resolver.resolve_multiple(&issuers).await?;
    
        // Validate the credentials in the presentation.
        let credential_validator: JwtCredentialValidator<EdDSAJwsVerifier> =
            JwtCredentialValidator::with_signature_verifier(EdDSAJwsVerifier::default());
        let validation_options: JwtCredentialValidationOptions =
            JwtCredentialValidationOptions::default().subject_holder_relationship(
                holder_did.to_url().into(),
                SubjectHolderRelationship::AlwaysSubject,
            );
    
        for (index, jwt_vc) in jwt_credentials.iter().enumerate() {
            // SAFETY: Indexing should be fine since we extracted the DID from each credential and resolved it.
            let issuer_document: &IotaDocument = &issuers_documents[&issuers[index]];
    
            let _decoded_credential: DecodedJwtCredential<Object> = credential_validator
                .validate::<_, Object>(
                    jwt_vc,
                    issuer_document,
                    &validation_options,
                    FailFast::FirstError,
                )
                .unwrap();
        }
    
        // Since no errors were thrown by `verify_presentation` we know that the validation was successful.
        println!(
            "VP successfully validated: {:#?}",
            presentation.presentation
        );
    
        Ok(())
    }
    
    Ok(())
}
